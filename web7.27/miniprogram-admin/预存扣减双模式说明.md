# 预存扣减双模式说明

## 概述

预存记录支持两种扣减方式，满足不同的业务场景需求：

1. **金额型预存** (`type: 'amount'`) - 按金额扣减
2. **产品型预存** (`type: 'product'`) - 按数量扣减

## 两种模式对比

### 1. 金额型预存 (Amount Type)

**特点：**
- 存储的是货币金额（如：¥100.00）
- 可以抵扣任意商品的费用
- 灵活度高，通用性强

**使用场景：**
- 客户充值预存金额
- 礼品卡余额
- 会员积分（按金额计算）
- 优惠券余额

**数据结构：**
```javascript
{
  _id: "record_id",
  customerId: "customer_id",
  type: "amount",
  productName: "预存金额",
  balance: 100.00, // 余额（元）
  createTime: "2024-01-01T00:00:00.000Z"
}
```

**扣减逻辑：**
```javascript
// 扣减金额
const deductAmount = Math.min(remainingAmount, availableBalance);
const newBalance = availableBalance - deductAmount;
```

### 2. 产品型预存 (Product Type)

**特点：**
- 存储的是具体商品的数量（如：5个苹果）
- 只能抵扣指定商品
- 精确控制，避免滥用

**使用场景：**
- 预存特定商品（如：10个苹果）
- 礼品券（指定商品）
- 会员专享商品
- 限时优惠商品

**数据结构：**
```javascript
{
  _id: "record_id",
  customerId: "customer_id",
  type: "product",
  productName: "苹果",
  productId: "product_id", // 关联商品ID
  balance: 5, // 余额（个）
  createTime: "2024-01-01T00:00:00.000Z"
}
```

**扣减逻辑：**
```javascript
// 扣减数量
const deductAmount = Math.min(remainingAmount, availableBalance);
const newBalance = availableBalance - deductAmount;
```

## 技术实现

### 1. 云函数参数

```javascript
// 金额型扣减
await app.callFunction({
  name: 'updatePrepaidBalance',
  data: {
    customerId: 'customer_id',
    customerPhone: '13800138000',
    amount: 50.00, // 扣减金额
    orderId: 'ORD123456',
    prepaidType: 'amount'
  }
});

// 产品型扣减
await app.callFunction({
  name: 'updatePrepaidBalance',
  data: {
    customerId: 'customer_id',
    customerPhone: '13800138000',
    amount: 1, // 扣减数量
    orderId: 'ORD123456',
    prepaidType: 'product'
  }
});
```

### 2. 前端界面区分

**金额型预存显示：**
```jsx
<div className="flex items-center gap-3">
  <CurrencyDollarIcon className="w-5 h-5 text-primary" />
  <div>
    <div className="font-medium">预存金额</div>
    <div className="text-sm text-base-content/60">
      余额: ¥{record.balance.toFixed(2)}
    </div>
  </div>
</div>
```

**产品型预存显示：**
```jsx
<div className="flex items-center gap-3">
  <CubeIcon className="w-5 h-5 text-primary" />
  <div>
    <div className="font-medium">{record.productName}</div>
    <div className="text-sm text-base-content/60">
      余额: {record.balance}个
    </div>
  </div>
</div>
```

### 3. 支付方式映射

| 支付方式 | 预存类型 | 扣减逻辑 | 实付金额 |
|---------|---------|---------|---------|
| `prestore` | `amount` | 扣减金额 | 总价 - 扣减金额 |
| `prepaid` | `product` | 扣减数量 | 0（完全抵扣） |

## 业务逻辑

### 1. 金额型预存流程

```
1. 客户选择预存金额记录
2. 系统计算可扣减金额 = min(预存余额, 订单总价)
3. 用户确认扣减金额
4. 提交订单时调用云函数扣减
5. 实付金额 = 订单总价 - 扣减金额
```

### 2. 产品型预存流程

```
1. 客户选择预存产品记录
2. 系统验证产品是否匹配
3. 用户确认使用预存产品
4. 提交订单时调用云函数扣减
5. 实付金额 = 0（完全抵扣）
```

## 数据库设计

### 1. 预存记录表 (prepaidRecords)

```javascript
{
  _id: String,           // 记录ID
  customerId: String,    // 客户ID
  customerPhone: String, // 客户电话
  type: String,          // 类型：'amount' 或 'product'
  productName: String,   // 产品名称
  productId: String,     // 产品ID（产品型必填）
  balance: Number,       // 余额
  createTime: Date,      // 创建时间
  updateTime: Date       // 更新时间
}
```

### 2. 扣减记录表 (prepaidDeductions)

```javascript
{
  _id: String,           // 记录ID
  customerId: String,    // 客户ID
  customerPhone: String, // 客户电话
  orderId: String,       // 订单ID
  type: String,          // 扣减类型：'amount' 或 'product'
  totalAmount: Number,   // 总扣减金额/数量
  deductedAmount: Number, // 实际扣减金额/数量
  details: Array,        // 扣减详情
  createTime: Date,      // 创建时间
  status: String         // 状态：'completed'
}
```

## 错误处理

### 1. 金额型预存错误

```javascript
// 余额不足
if (totalPrepaidBalance < orderForm.prepaidAmount) {
  alert('预存余额不足');
  return;
}

// 扣减失败
if (!prepaidSuccess) {
  console.warn('预存金额扣减失败，但订单和库存扣减已成功');
}
```

### 2. 产品型预存错误

```javascript
// 产品余额不足
if (!selectedProduct || selectedProduct.balance <= 0) {
  alert('预存产品余额不足');
  return;
}

// 产品不匹配
if (selectedProduct.productId !== cartItem.productId) {
  alert('预存产品与购物车商品不匹配');
  return;
}
```

## 监控和统计

### 1. 金额型预存统计

```javascript
// 总预存金额
const totalAmount = prepaidRecords
  .filter(record => record.type === 'amount')
  .reduce((sum, record) => sum + record.balance, 0);

// 本月扣减金额
const monthlyDeduction = await db.collection('prepaidDeductions')
  .where({
    type: 'amount',
    createTime: db.command.gte(startOfMonth)
  })
  .get();
```

### 2. 产品型预存统计

```javascript
// 各产品预存数量
const productStats = prepaidRecords
  .filter(record => record.type === 'product')
  .reduce((stats, record) => {
    const productName = record.productName;
    stats[productName] = (stats[productName] || 0) + record.balance;
    return stats;
  }, {});
```

## 最佳实践

### 1. 数据一致性

- 使用事务确保扣减操作的原子性
- 扣减失败时自动回滚
- 记录详细的扣减日志

### 2. 用户体验

- 清晰区分两种预存类型
- 提供直观的余额显示
- 支持快速选择和使用

### 3. 业务规则

- 金额型预存可以部分使用
- 产品型预存必须完全匹配
- 支持多种预存记录组合使用

### 4. 性能优化

- 批量处理多个预存记录
- 减少数据库查询次数
- 使用索引优化查询性能

## 总结

通过支持两种预存扣减模式，系统能够：

1. **灵活应对不同业务场景**：金额型适合通用抵扣，产品型适合精确控制
2. **提供更好的用户体验**：客户可以根据需要选择不同的预存方式
3. **确保数据一致性**：通过事务处理避免数据不一致
4. **支持复杂的营销策略**：可以组合使用多种预存方式

这种设计既满足了通用性需求，又保证了业务控制的精确性，是一个完整且实用的预存管理系统。
