# 预存扣减问题修复说明

## 修复的问题

### 1. 地址自动填充问题

**问题描述：**
选择客户后，地址字段没有自动填充客户地址信息。

**原因分析：**
- 客户地址数据结构不统一，可能是字符串或对象
- 地址字段映射逻辑不完整
- 没有处理多种地址格式

**修复方案：**
```javascript
// 构建完整地址
let fullAddress = '';
if (c.address) {
  if (typeof c.address === 'string') {
    fullAddress = c.address;
  } else if (c.address.fullAddress) {
    fullAddress = c.address.fullAddress;
  } else if (c.address.address) {
    fullAddress = c.address.address;
  } else if (c.address.province || c.address.city || c.address.district || c.address.detail) {
    // 拼接省市区详细地址
    const parts = [
      c.address.province,
      c.address.city,
      c.address.district,
      c.address.detail
    ].filter(Boolean);
    fullAddress = parts.join('');
  }
}
```

**支持的地址格式：**
1. 字符串格式：`"北京市朝阳区xxx街道"`
2. 对象格式：`{ fullAddress: "北京市朝阳区xxx街道" }`
3. 对象格式：`{ address: "北京市朝阳区xxx街道" }`
4. 分段格式：`{ province: "北京市", city: "朝阳区", district: "xxx区", detail: "xxx街道" }`

### 2. 预存产品筛选问题

**问题描述：**
选择客户后，显示该客户的全部预存信息，而不是只显示与当前购物车商品匹配的预存产品。

**原因分析：**
- 查询预存记录时没有考虑购物车商品
- 没有区分金额型预存和产品型预存的查询逻辑
- 缺少预存记录与购物车商品的匹配验证

**修复方案：**

#### 2.1 智能查询逻辑
```javascript
// 获取购物车中的商品ID列表
const cartProductIds = cart.map(item => item._id);

// 查询预存记录
let query = db.collection('prepaidRecords').where({
  customerId: customerId,
  balance: db.command.gt(0)
});

// 如果有购物车商品，只查询匹配的预存产品
if (cartProductIds.length > 0) {
  query = query.where(db.command.or([
    // 金额型预存（可以抵扣任意商品）
    { type: 'amount' },
    // 产品型预存（只显示购物车中有的商品）
    db.command.and([
      { type: 'product' },
      { productId: db.command.in(cartProductIds) }
    ])
  ]));
} else {
  // 购物车为空时，只显示金额型预存
  query = query.where({ type: 'amount' });
}
```

#### 2.2 匹配验证逻辑
```javascript
// 检查预存记录是否与购物车商品匹配
const isPrepaidRecordMatched = (record) => {
  if (record.type === 'amount') {
    return true; // 金额型预存可以抵扣任意商品
  }
  if (record.type === 'product') {
    return cart.some(item => item._id === record.productId);
  }
  return false;
};
```

#### 2.3 界面显示优化
```javascript
// 预存记录显示
{prepaidRecords.map(record => {
  const isMatched = isPrepaidRecordMatched(record);
  return (
    <div className={`flex items-center justify-between p-3 rounded-lg ${
      isMatched ? 'bg-base-200' : 'bg-base-300 opacity-60'
    }`}>
      <div className="flex items-center gap-3">
        <Icon className="w-5 h-5 text-primary" />
        <div>
          <div className="font-medium">{record.productName || '预存金额'}</div>
          <div className="text-sm text-base-content/60">
            {getPrepaidRecordText(record)}
            {!isMatched && record.type === 'product' && (
              <span className="text-warning ml-2">(不在购物车中)</span>
            )}
          </div>
        </div>
      </div>
      <button
        className={`btn btn-sm ${isMatched ? 'btn-primary' : 'btn-disabled'}`}
        onClick={() => isMatched && selectPrepaidRecord(record)}
        disabled={!isMatched}
      >
        使用
      </button>
    </div>
  );
})}
```

## 修复效果

### 1. 地址自动填充
- ✅ 选择客户后自动填充地址
- ✅ 支持多种地址数据格式
- ✅ 智能拼接分段地址信息
- ✅ 控制台输出调试信息

### 2. 预存产品筛选
- ✅ 只显示与购物车商品匹配的预存产品
- ✅ 金额型预存始终显示（可抵扣任意商品）
- ✅ 产品型预存只显示购物车中有的商品
- ✅ 购物车为空时只显示金额型预存
- ✅ 不匹配的预存记录显示为禁用状态
- ✅ 添加提示信息说明筛选逻辑

## 技术细节

### 1. 依赖更新
```javascript
// 添加cart依赖，购物车变化时重新查询预存记录
useEffect(() => {
  if (orderForm.customerId) {
    fetchPrepaidRecords(orderForm.customerId);
  }
}, [orderForm.customerId, cart]); // 添加cart依赖
```

### 2. 查询优化
```javascript
// 使用复合查询条件
query = query.where(db.command.or([
  { type: 'amount' }, // 金额型预存
  db.command.and([    // 产品型预存
    { type: 'product' },
    { productId: db.command.in(cartProductIds) }
  ])
]));
```

### 3. 用户体验优化
- 添加提示文字说明筛选逻辑
- 不匹配的预存记录显示为灰色禁用状态
- 添加"(不在购物车中)"提示
- 控制台输出调试信息便于排查问题

## 测试场景

### 1. 地址自动填充测试
1. 添加商品到购物车
2. 点击"立即下单"
3. 点击"选择客户"
4. 选择一个有地址信息的客户
5. 验证地址字段是否自动填充

### 2. 预存产品筛选测试
1. 添加商品A到购物车
2. 选择有预存记录的客户
3. 验证只显示商品A的预存记录和金额型预存
4. 添加商品B到购物车
5. 验证现在显示商品A、B的预存记录和金额型预存
6. 清空购物车
7. 验证只显示金额型预存

### 3. 边界情况测试
1. 购物车为空时的预存记录显示
2. 客户没有预存记录时的显示
3. 预存记录余额为0时的显示
4. 地址信息为空时的处理

## 总结

通过这次修复，系统现在能够：

1. **智能填充地址**：支持多种地址格式，自动填充客户地址信息
2. **精确筛选预存**：只显示与当前购物车商品匹配的预存记录
3. **优化用户体验**：清晰的视觉反馈和操作提示
4. **提高数据准确性**：避免使用不匹配的预存记录

这些修复确保了预存扣减功能的准确性和用户体验的流畅性。
